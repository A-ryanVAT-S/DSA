| Algorithm        | Use Case                           | Weighted? | Negative Weights? | Directed? | Result                      |
| ---------------- | ---------------------------------- | --------- | ----------------- | --------- | --------------------------- |
| BFS              | Shortest path (unweighted), levels | ‚ùå         | ‚ùå                 | ‚úÖ         | Distances / traversal       |
| DFS              | Cycle detection, components        | ‚ùå         | ‚ùå                 | ‚úÖ         | Traversal / exploration     |
| Dijkstra         | Shortest path (weighted)           | ‚úÖ         | ‚ùå                 | ‚úÖ         | Shortest paths from source  |
| Bellman-Ford     | Shortest path (neg weights)        | ‚úÖ         | ‚úÖ                 | ‚úÖ         | Shortest paths / detect neg |
| Floyd-Warshall   | All-pairs shortest path            | ‚úÖ         | ‚úÖ                 | ‚úÖ         | Distances matrix            |
| Prim‚Äôs           | MST (dense, undirected)            | ‚úÖ         | ‚ùå                 | ‚ùå         | MST total weight            |
| Kruskal‚Äôs        | MST (sparse, undirected)           | ‚úÖ         | ‚ùå                 | ‚ùå         | MST edges                   |
| Topo Sort        | Scheduling in DAG                  | ‚ùå         | ‚ùå                 | ‚úÖ (DAG)   | Linear order                |
| Tarjan/Kosaraju  | Strongly connected components      | ‚ùå         | ‚ùå                 | ‚úÖ         | List of SCCs                |
| Union-Find (DSU) | Cycle detection, grouping          | ‚ùå         | ‚ùå                 | ‚ùå         | Sets / components           |
| Bridges/AP       | Network reliability                | ‚ùå         | ‚ùå                 | ‚ùå         | Critical edges/nodes        |

### üìò Graph Algorithms ‚Äì Pseudocode & Intuitions

---

#### 1. **BFS (Breadth-First Search)**

**Use**: Shortest path (unweighted), level-order traversal

```pseudo
BFS(graph, start):
    queue = empty queue
    visited = set
    queue.push(start)
    visited.add(start)

    while queue not empty:
        node = queue.pop()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.push(neighbor)
```

---

#### 2. **DFS (Depth-First Search)**

**Use**: Cycle detection, connected components

```pseudo
DFS(graph, node, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            DFS(graph, neighbor, visited)
```

---

#### 3. **Dijkstra's Algorithm**

**Use**: Shortest path (non-negative weights)

```pseudo
Dijkstra(graph, source):
    dist[] = [INF] * n
    dist[source] = 0
    minHeap = priority queue of {dist, node}

    while minHeap not empty:
        [d, u] = minHeap.pop()
        for [v, weight] in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                minHeap.push([dist[v], v])
```

---

#### 4. **Bellman-Ford Algorithm**

**Use**: Shortest path (can handle negative weights)

```pseudo
BellmanFord(edges, V, source):
    dist[] = [INF] * V
    dist[source] = 0

    for i = 1 to V-1:
        for (u, v, wt) in edges:
            if dist[u] + wt < dist[v]:
                dist[v] = dist[u] + wt

    // Check for negative cycles
    for (u, v, wt) in edges:
        if dist[u] + wt < dist[v]:
            report negative cycle
```

---

#### 5. **Floyd-Warshall Algorithm**

**Use**: All-pairs shortest path

```pseudo
FloydWarshall(graph):
    dist = graph[][] // adjacency matrix
    for k in 0 to V-1:
        for i in 0 to V-1:
            for j in 0 to V-1:
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
```

---

#### 6. **Prim's Algorithm (MST)**

**Use**: Minimum spanning tree

```pseudo
Prim(graph):
    mstSet = set()
    minHeap = priority queue of {weight, node}
    totalWeight = 0
    minHeap.push({0, 0})

    while minHeap not empty:
        [wt, u] = minHeap.pop()
        if u in mstSet: continue
        mstSet.add(u)
        totalWeight += wt
        for [v, weight] in graph[u]:
            if v not in mstSet:
                minHeap.push([weight, v])
```

---

#### 7. **Kruskal's Algorithm (MST)**

**Use**: MST using Disjoint Set

```pseudo
Kruskal(edges, V):
    sort edges by weight
    parent[] = [i for i in range(V)]
    rank[] = [0]*V

    function find(u):
        if parent[u] != u:
            parent[u] = find(parent[u])
        return parent[u]

    function union(u, v):
        rootU = find(u)
        rootV = find(v)
        if rootU != rootV:
            if rank[rootU] < rank[rootV]: parent[rootU] = rootV
            elif rank[rootU] > rank[rootV]: parent[rootV] = rootU
            else: parent[rootV] = rootU; rank[rootU] += 1

    MST = []
    for (u, v, wt) in edges:
        if find(u) != find(v):
            MST.append((u, v))
            union(u, v)
```

---

#### 8. **Topological Sort (DFS)**

**Use**: Linear ordering (DAG)

```pseudo
TopoSort(graph):
    visited = set()
    stack = []

    function dfs(u):
        visited.add(u)
        for v in graph[u]:
            if v not in visited:
                dfs(v)
        stack.append(u)

    for node in graph:
        if node not in visited:
            dfs(node)

    return reversed(stack)
```

---

#### 9. **Cycle Detection (Undirected - DFS)**

```pseudo
hasCycle(graph, u, visited, parent):
    visited.add(u)
    for v in graph[u]:
        if v not in visited:
            if hasCycle(graph, v, visited, u): return True
        elif v != parent:
            return True
    return False
```

---

#### 10. **Tarjan‚Äôs Algorithm (SCC)**

```pseudo
TarjanSCC(graph):
    index = 0
    indices = [-1] * V
    lowlink = [-1] * V
    stack = []
    onStack = [False] * V
    result = []

    function strongconnect(v):
        indices[v] = lowlink[v] = index
        index += 1
        stack.append(v); onStack[v] = True

        for w in graph[v]:
            if indices[w] == -1:
                strongconnect(w)
                lowlink[v] = min(lowlink[v], lowlink[w])
            elif onStack[w]:
                lowlink[v] = min(lowlink[v], indices[w])

        if lowlink[v] == indices[v]:
            scc = []
            while True:
                w = stack.pop()
                onStack[w] = False
                scc.append(w)
                if w == v: break
            result.append(scc)
```

---

Let me know if you want C++ code for each or visual diagrams!
